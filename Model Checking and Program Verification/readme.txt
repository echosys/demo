Theoretical Computer Science Project Principles of Model Checking and Program Verification
In this project we used Finite automata to model terminating software programs or discrete event systems. Similarly, the expected behavior of the environment can be captured by an automaton whose “composition” with the model of the system can model the interaction of the environment with the system. In this project, we will assume that we have a model of the system interacting with its environment and we would like to verify whether the execution of the system satisfies a specification given as another automaton (specification automaton).

In theoretic terms, the system-environment automaton A accepts a language L(A) which consists of strings that generate paths on the automaton that represent the actual behavior of the system in its environment. Our goal is to find whether this language is a subset of the language L(S) that is accepted by the specification automaton S, L(A) <= L(S). Moreover, if it is not the case that L(A) <= L(S), then we must provide a string w which demonstrates that w belongs in L(A), but is not in L(S). This implies that w is a counterexample for the correctness of the system. In practice, the counterexample can provide feedback to the software engineer on how the system fails. 

In terms of implementation done in Python, we first read the specification automaton S and model of the system A from a text file. Since both automata A and S could be nondeterministic, we then convert them to deterministic automata. Next we convert the automaton S into a new automaton S’ that accepts the complement of L(S) to construct a new automaton M which accepts the language L(M) = L(A) inner joins L(S)'s complement. Last we try to find a string w that belongs in L(M) by searching for a path from the initial state of M to a final state in M and returning a string that will generate this path. If no string can be found, that is, the language of L(M) is empty, then it means the system satisfies the specification. 